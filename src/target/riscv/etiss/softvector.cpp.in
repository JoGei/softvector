/*
 * Copyright [2020] [Technical University of Munich]
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//////////////////////////////////////////////////////////////////////////////////////
/// \file softvector.cpp
/// \brief C++ Source for ETISS JIT libary or independent C application. Implements a C interface when compiled to library beforehand
/// \date 06/23/2020
//////////////////////////////////////////////////////////////////////////////////////

#include "softvector.h"
#include "base/base.hpp"
#include "lsu/lsu.hpp"
#include "arithmetic/integer.hpp"

#include "etiss/jit/CPU.h"
#include "etiss/jit/System.h"
#include "@TARGET_ARCH@.h"
#define ETISSCPU_SPEC @TARGET_ARCH@

extern "C"
{

int8_t vtype_decode(uint16_t vtype, uint8_t* ta, uint8_t* ma, uint32_t* sew, uint8_t* z_lmul, uint8_t* n_lmul){
	return (VTYPE::decode(vtype, ta , ma, sew, z_lmul, n_lmul));
}

uint16_t vtype_encode(uint16_t sew, uint8_t z_lmul, uint8_t n_lmul, uint8_t ta, uint8_t ma){
	return VTYPE::encode(sew, z_lmul, n_lmul, ta, ma);
}

uint8_t vtype_extractSEW(uint16_t pVTYPE)
{
	return VTYPE::extractSEW(pVTYPE);
}

uint8_t vtype_extractLMUL(uint16_t pVTYPE)
{
	return VTYPE::extractLMUL(pVTYPE);
}

uint8_t vtype_extractTA(uint16_t pVTYPE)
{
	return VTYPE::extractTA(pVTYPE);
}

uint8_t vtype_extractMA(uint16_t pVTYPE)
{
	return VTYPE::extractMA(pVTYPE);
}

uint16_t vcfg_concatEEW(uint8_t mew, uint8_t width){
	return (VTYPE::concatEEW(mew, width));
}

uint8_t vload_encoded_unitstride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t  pVm, uint16_t pEEW, uint8_t  pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*8) || (_z_emul > _n_emul*8)) return 1;


	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_readMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dread))(pSystem->handle, pCpu, addr, buff, len);
    };

    VLSU::load_eew(f_readMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd, pMSTART, pVSTART, pVm, 0);
    return (0);
}

uint8_t vload_encoded_stride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t  pVm, uint16_t pEEW, uint8_t  pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART, int16_t pSTRIDE)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*8) || (_z_emul > _n_emul*8)){
        return 1;
    }

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_readMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dread))(pSystem->handle, pCpu, addr, buff, len);
    };

    VLSU::load_eew(f_readMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd, pMSTART, pVSTART, pVm, pSTRIDE);

    return (0);
}

uint8_t vload_segment_unitstride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t  pVm, uint16_t pEEW, uint8_t pNF, uint8_t pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*pNF*8) || (_z_emul*pNF > _n_emul*8)) return 1;
    if ((pVd + pNF*_z_emul/_n_emul) > 32) return 1;
    if (pVSTART >= pVL) return (0);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_readMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dread))(pSystem->handle, pCpu, addr, buff, len);
    };

    uint16_t _vstart = pVSTART;
    uint64_t _moffset = pMSTART;
    for(int i = 0; i< pNF; ++i){
        VLSU::load_eew(f_readMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd + (i*_z_emul/_n_emul), _moffset, _vstart, pVm, 0);
        _moffset+= (pVL-_vstart)*pEEW/8;
        _vstart = 0;
    }
    return (0);
}

uint8_t vload_segment_stride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint16_t pEEW, uint8_t pNF, uint8_t pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART, int16_t pSTRIDE)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*pNF*8) || (_z_emul*pNF > _n_emul*8)) return 1;
    if ((pVd + pNF*_z_emul/_n_emul) > 32) return 1;
    if (pVSTART >= pVL) return (0);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_readMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dread))(pSystem->handle, pCpu, addr, buff, len);
    };

    uint16_t _vstart = pVSTART;
    uint64_t _moffset = pMSTART;
    for(int i = 0; i< pNF; ++i){
        _moffset = pMSTART + i*pEEW/8;
        VLSU::load_eew(f_readMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd + (i*_z_emul/_n_emul), _moffset, _vstart, pVm, pSTRIDE);
        _vstart = 0;
    }
    return (0);
}

uint8_t vstore_encoded_unitstride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint16_t pEEW, uint8_t pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*8) || (_z_emul > _n_emul*8)) return 1;

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_writeMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dwrite))(pSystem->handle, pCpu, addr, buff, len);
    };

    VLSU::store_eew(f_writeMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd, pMSTART, pVSTART, pVm, 0);

    return (0);
}

uint8_t vstore_encoded_stride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint16_t pEEW, uint8_t pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART, int16_t pStride)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*8) || (_z_emul > _n_emul*8)) return 1;

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_writeMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dwrite))(pSystem->handle, pCpu, addr, buff, len);
    };

    VLSU::store_eew(f_writeMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd, pMSTART, pVSTART, pVm, pStride);

    return (0);
}

uint8_t vstore_segment_unitstride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t  pVm, uint16_t pEEW, uint8_t pNF, uint8_t pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*pNF*8) || (_z_emul*pNF > _n_emul*8)) return 1;
    if ((pVd + pNF*_z_emul/_n_emul) > 32) return 1;
    if (pVSTART >= pVL) return (0);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_writeMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dwrite))(pSystem->handle, pCpu, addr, buff, len);
    };

    uint16_t _vstart = pVSTART;
    uint64_t _moffset = pMSTART;
    for(int i = 0; i< pNF; ++i){
        VLSU::store_eew(f_writeMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd + (i*_z_emul/_n_emul), _moffset, _vstart, pVm, 0);
        _moffset+= (pVL-_vstart)*pEEW/8;
        _vstart = 0;
    }
    return (0);
}

uint8_t vstore_segment_stride(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t  pVm, uint16_t pEEW, uint8_t pNF, uint8_t pVd, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint64_t pMSTART, int16_t pStride)
{
    VTYPE::VTYPE _vt(pVTYPE);
    uint64_t _z_emul = pEEW*_vt._z_lmul;
    uint64_t _n_emul = _vt._sew*_vt._n_lmul;

    if ((_n_emul > _z_emul*pNF*8) || (_z_emul*pNF > _n_emul*8)) return 1;
    if ((pVd + pNF*_z_emul/_n_emul) > 32) return 1;
    if (pVSTART >= pVL) return (0);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    std::function<void(size_t, uint8_t*, size_t)> f_writeMem = [pSystem, pCpu](size_t addr, uint8_t* buff, size_t len) {
    	(*(pSystem->dwrite))(pSystem->handle, pCpu, addr, buff, len);
    };

	uint16_t _vstart = pVSTART;
    uint64_t _moffset = pMSTART;
    for(int i = 0; i< pNF; ++i){
    	_moffset = pMSTART + i*pEEW/8;
        VLSU::store_eew(f_writeMem, VectorRegField, _z_emul, _n_emul, pEEW/8, pVL, pVLEN/8, pVd + (i*_z_emul/_n_emul), _moffset, _vstart, pVm, 0);
        _moffset+= (pVL-_vstart)*pEEW/8;
       _vstart = 0;
    }
    return (0);
}

/* Vector Arithmetic functions*/

uint8_t vadd_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::add_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vadd_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::add_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vadd_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::add_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}

uint8_t vsub_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::sub_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vsub_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::sub_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}

uint8_t vand_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::and_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vand_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::and_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vand_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::and_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}

uint8_t vor_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::or_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vor_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::or_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vor_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::or_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}

uint8_t vxor_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::xor_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vxor_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::xor_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vxor_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
	uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
    
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
    uint8_t* ScalarReg	= (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::xor_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}


uint8_t vsll_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::sll_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vsll_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::sll_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vsll_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::sll_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}

uint8_t vsrl_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::srl_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vsrl_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::srl_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vsrl_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::srl_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}

uint8_t vsra_vv(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs1, uint8_t pVs2, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::sra_vv(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs1, pVs2, pVSTART, pVm);

    return (0);
}

uint8_t vsra_vi(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pVimm, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL)
{
    VTYPE::VTYPE _vt(pVTYPE);

	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;

    VARITH::sra_vi(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, pVimm, pVSTART, pVm);

    return (0);
}

uint8_t vsra_vx(
	ETISS_CPU* const pCpu,
	ETISS_System* const pSystem,
    uint16_t pVTYPE, uint8_t pVm, uint8_t pVd, uint8_t pVs2, uint8_t pRs1, uint16_t pVSTART, uint16_t pVLEN, uint16_t pVL, uint8_t pXLEN)
{
    VTYPE::VTYPE _vt(pVTYPE);
	uint8_t* VectorRegField = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->V;
	uint8_t* ScalarReg = (uint8_t*)((ETISSCPU_SPEC*)pCpu)->X[pRs1];

    VARITH::sra_vx(VectorRegField, _vt._z_lmul, _vt._n_lmul, _vt._sew / 8, pVL, pVLEN / 8, pVd, pVs2, ScalarReg, pVSTART, pVm, pXLEN/8);

    return (0);
}


} // extern "C"
